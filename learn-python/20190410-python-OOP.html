<!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="https://fonts.loli.net/css?family=Noto+Serif+SC:400,500,700&display=swap&subset=chinese-simplified" rel="stylesheet"><link href="https://fonts.loli.net/css?family=Parisienne" rel="stylesheet"><link href="https://fonts.loli.net/css?family=Pinyon+Script" rel="stylesheet"><link href="https://fonts.loli.net/css?family=EB+Garamond:400,500,700" rel="stylesheet"><link href="https://fonts.loli.net/css?family=Source+Code+Pro:400,700" rel="stylesheet"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/logo-32x32.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/logo-16x16.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="学习笔记,python,"><meta name="description" content="文章第一部分介绍了什么对象，对象有什么优点（多态，封装，继承）以及什么时候要使用对象；第二部分从类的结构入手，说明它的语法规则；第三部分介绍了类与对象的名称空间；第四部分介绍类与类之间的关系；第五部分再次谈到继承涉及多继承的顺序、抽象类等规范化开发；第六部分谈谈类中的双下划线方法和用到的一些内置函数；最后一部分是对概念，面向对象设计的总结。本文参考了《Python基础教程》《Python核心编程》"><meta name="keywords" content="学习笔记,python"><meta property="og:type" content="article"><meta property="og:title" content="Python之面向对象"><meta property="og:url" content="https://chennq.top/learn-python/20190410-python-OOP.html"><meta property="og:site_name" content="Naqin"><meta property="og:description" content="文章第一部分介绍了什么对象，对象有什么优点（多态，封装，继承）以及什么时候要使用对象；第二部分从类的结构入手，说明它的语法规则；第三部分介绍了类与对象的名称空间；第四部分介绍类与类之间的关系；第五部分再次谈到继承涉及多继承的顺序、抽象类等规范化开发；第六部分谈谈类中的双下划线方法和用到的一些内置函数；最后一部分是对概念，面向对象设计的总结。本文参考了《Python基础教程》《Python核心编程》"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="https://chennq.top/learn-python/20190410-python-OOP/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4.png"><meta property="og:updated_time" content="2019-11-04T17:09:18.719Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Python之面向对象"><meta name="twitter:description" content="文章第一部分介绍了什么对象，对象有什么优点（多态，封装，继承）以及什么时候要使用对象；第二部分从类的结构入手，说明它的语法规则；第三部分介绍了类与对象的名称空间；第四部分介绍类与类之间的关系；第五部分再次谈到继承涉及多继承的顺序、抽象类等规范化开发；第六部分谈谈类中的双下划线方法和用到的一些内置函数；最后一部分是对概念，面向对象设计的总结。本文参考了《Python基础教程》《Python核心编程》"><meta name="twitter:image" content="https://chennq.top/learn-python/20190410-python-OOP/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"5.1.4",sidebar:{position:"left",display:"hide",offset:12,b2t:!1,scrollpercent:!0,onmobile:!1,dimmer:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!0,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://chennq.top/learn-python/20190410-python-OOP.html"><title>Python之面向对象 | Naqin</title><meta name="baidu-site-verification" content="rqAw8UHNKS"><meta name="google-site-verification" content="r_iyjm0f8KcvC9kIpQiyZx3pmWlLY-gwBv9KsOF2AYo"></head><body itemscope itemtype="https://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="https://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Naqin</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">Run! Forest,run!</h1></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section">首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section">关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section">标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section">分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section">归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger">搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="https://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://chennq.top/learn-python/20190410-python-OOP.html"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Naqin"><meta itemprop="description" content><meta itemprop="image" content="/uploads/tu6.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Naqin"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">Python之面向对象</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-10T12:08:36+08:00">2019-04-10 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/learn-python/" itemprop="url" rel="index"><span itemprop="name">python学习</span></a></span></span><div class="post-wordcount"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">11.7k 字</span></div></div></header><div class="post-body" itemprop="articleBody"><blockquote class="blockquote-center"><p>文章第一部分介绍了什么对象，对象有什么优点（多态，封装，继承）以及什么时候要使用对象；第二部分从类的结构入手，说明它的语法规则；第三部分介绍了类与对象的名称空间；第四部分介绍类与类之间的关系；第五部分再次谈到继承涉及多继承的顺序、抽象类等规范化开发；第六部分谈谈类中的双下划线方法和用到的一些内置函数；最后一部分是对概念，面向对象设计的总结。本文参考了《Python基础教程》《Python核心编程》。</p></blockquote><a id="more"></a><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>创建自定义对象（尤其是对象类型或类）是一个Python核心概念，这个概念非常重要，以至于Python与Smalltalk、C++、Java等众多语言一样，被视为一种面向对象的语言。</p><h2 id="对象魔法"><a href="#对象魔法" class="headerlink" title="对象魔法"></a>对象魔法</h2><ul><li>在面向对象编程中，术语<strong>对象</strong>大致意味着一系列<strong>数据（属性）</strong>以及一套访问和操作这些数据的<strong>方法</strong>。</li><li>使用对象的最重要的好处。：<ol><li>多态：可对<strong>不同类型的对象执行相同</strong>的操作，而这些操作就像“被施了魔法”一样能够正常运行。</li><li>封装：<strong>对外部隐藏</strong>有关对象工作原理的细节。</li><li>继承：可基于通用类创建出专用类。</li></ol></li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul><li><p>术语多态（polymorphism）源自希腊语，意思是“有多种形态”。这大致意味着即便你不知道变量指向的是哪种对象，也能够对其执行操作，且操作的行为将随对象所属的类型（类）而异。</p></li><li><p>例子：假设你要为一个销售食品的电子商务网站创建在线支付系统，程序将接收来自系统另一部分（或之后设计的类似系统）的购物车。因此你只需计算总价并从信用卡扣除费用即可。</p><p>​ 你首先想到的可能是，指定程序收到商品时必须如何表示。例如，你可能要求用元组表示收到的商品，如下所示：</p><p><code>(&#39;SPAM&#39;, 2.50)</code></p><p>​ 但当价格可能存在一个变动的时候（打折），简单的元组就不够用了，再来一个神奇的网络方法吧，它可以得到变动后的价格。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不要像下面这样做： </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_price</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> isinstance(object, tuple):     </span><br><span class="line">		<span class="keyword">return</span> object[<span class="number">1</span>]    </span><br><span class="line">	<span class="keyword">else</span>:  </span><br><span class="line">		<span class="keyword">return</span> magic_network_method(object)</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：这里使用<code>isinstance</code>来执行类型/类检查旨在说明：使用类型检查通常是馊主意，应尽可能避免。</p><p>补充：①要破坏多态，唯一的办法是使用诸如type、issubclass、isinstance等函数显式地执行类型检查，但你应尽可能避免以这种方式破坏多态。我们的<strong>目标</strong>是：<u>对象按你希望的那样行事，而非它是否是正确的类型（类）</u>。</p><p>​ ②这里讨论的多态形式是Python编程方式的核心，有时称为<strong>鸭子类型</strong>。这个术语源自如下说法：“<u>如果走起来像鸭子，叫起来像鸭子，那么它就是鸭子。</u>”</p></blockquote><blockquote><p>鸭子类型：<u>所有的类型制定了规范</u>（如不同的类有相同的方法名，如len方法的本质，含有 <code>__len__</code>方法的类，这样我们使用len(对象)就可以得到不同类型对象的长度）。</p><p>（另一种多态是从继承表现出来的）</p></blockquote><p>​ 前面的代码使用函数<code>isinstance</code>来检查object是否是元组。如果是，就返回其第二个元素， 否则调用一个神奇的网络方法。</p><p>​ 如果网络方法已就绪，问题就暂时解决了。但这种解决方案还是不太灵活。如果有位程序员很聪明，决定用十六进制的字符串表示价格，并将其存储在字典的’price’键下呢？没问题，你<u>只需更新相应的函数</u>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不要像下面这样做： </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_price</span><span class="params">(object)</span>:</span>  </span><br><span class="line">	<span class="keyword">if</span> isinstance(object, tuple):     </span><br><span class="line">		<span class="keyword">return</span> object[<span class="number">1</span>]    </span><br><span class="line">	<span class="keyword">elif</span> isinstance(object, dict):     </span><br><span class="line"><span class="keyword">return</span> int(object[<span class="string">'price'</span>])    </span><br><span class="line">	<span class="keyword">else</span>:  </span><br><span class="line"><span class="keyword">return</span> magic_network_method(object)</span><br></pre></td></tr></table></figure><p>​ 你确定现在考虑到了所有的可能性吗？①平时的想法就是那我就继续增加分支呗。</p><p>​ 假设有人决定添加一种新字典，并在其中将价格存储在另一个键下，你该如何办呢？当然，可再次更新get_price，每当有人以不同的方式实现对象时，②你都需要重新实现你的模块。</p><ul><li><p><strong>小结</strong>：面向过程处理这种情况需要：</p><p>① 当有新的类型的数据时可以增加分支</p><p>② 当这个类型的数据发生变化时，更改原来对于这个类型数据的处理方法（get_price）</p></li><li><p><strong>解决方法</strong>：让对象自己去处理这种操作，每种新对象都能够获取或计算其价格并返回结果，而你只需向它们询问价格即可。这正是多态（从某种程度上说还有封装）的用武之地。</p></li></ul><h2 id="多态和方法"><a href="#多态和方法" class="headerlink" title="多态和方法"></a>多态和方法</h2><ul><li><p>你收到一个对象，却根本不知道它是如何实现的——它可能是众多“形态”中的任何一种。 你只知道可以询问其价格，但这就够了。至于询问价格的方式，你应该很熟悉。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.get_price()</span><br></pre></td></tr></table></figure><p>像这样<u>与对象属性相关联的函数称为方法</u>。</p></li><li><p>抛开这个例子回顾以前，我们以前也见到很多多态的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'abc'</span>.count(<span class="string">'a'</span>) </span><br><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">2</span>, <span class="string">'a'</span>].count(<span class="string">'a'</span>) </span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>​ 如果有一个变量x，你无需知道它是字符串还是列表就能调用方法count：只要你向这个方法提供一个字符作为参数，它就能正常运行。</p></li><li><p>多态形式多样 （处处皆多态）</p><p>每当无需知道对象是什么样的就能对其执行操作时，都是多态在起作用。这不仅仅适用于<u>方法</u>，我们还通过<u>内置运算符和函数</u>大量使用了多态。请看下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> + <span class="number">2</span> </span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Fish'</span> + <span class="string">'license'</span> </span><br><span class="line"><span class="string">'Fishlicense'</span></span><br></pre></td></tr></table></figure><p>上述代码表明，加法运算符（+）既可用于数（这里是整数），也可用于字符串（以及其他类 型的序列）。 本质上是因为再int类，str类中定义了<code>__add__</code>方法。</p><p>​ 我们通常定义的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span>     </span><br><span class="line">	<span class="keyword">return</span> x + y </span><br><span class="line"><span class="comment"># 当然这里有一个小细节就是x和y应该是相同的类。如 1 + '1'就会报错</span></span><br></pre></td></tr></table></figure><p>​ 这也许有点傻，但重点在于参数可以是<u>任何支持加法的对象</u>。很多函数和运算符都是多态的，你编写的大多数函数也可能如此，即便你不是有意为之。每当你使用多态的函数和运算符时，多态都将发挥作用，这也体现了<strong>处处是多态</strong>。</p></li><li><p>小结：</p><ul><li>以上讨论的多态形式是Python编程方式的核心，有时称为鸭子类型。为了遵守某种规则/协议，我们定义了xx方法。</li><li>多态让你<u>无需知道对象所属的类（对象的类型）就能调用其方法</u>，这也是我们在面向对象思考的一个套路。</li></ul></li></ul><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ul><li><p><strong>封装（encapsulation）</strong>指的是向外部隐藏不必要的细节。这听起来有点像多态（无需知道对象的内部细节就可使用它）。这两个概念很像，因为它们都是<strong>抽象的原则</strong>。它们都像函数一样， 可帮助你处理程序的组成部分，让你无需关心不必要的细节。</p><p>​ 但封装不同于多态。多态让你无需知道对象所属的类（对象的类型）就能调用其方法，而封装让你无需知道对象的构造就能使用它。听起来还是有点像？下面来看一个使用了多态但没有使用封装的示例。假设你有一个名为OpenObject的类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>o = OpenObject() <span class="comment"># 对象就是这样创建的 </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o.set_name(<span class="string">'Sir Lancelot'</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o.get_name() </span><br><span class="line"><span class="string">'Sir Lancelot'</span></span><br></pre></td></tr></table></figure><p>​ 你（通过像调用函数一样调用类）创建一个对象，并将其关联到变量o，然后就可以使用方法set_name和get_name了（假设OpenObject支持这些方法）。一切都看起来完美无缺。然而，如果 o将其名称存储在全局变量global_name中呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>global_name </span><br><span class="line"><span class="string">'Sir Lancelot'</span></span><br></pre></td></tr></table></figure><p>​ 这意味着使用OpenObject类的实例（对象）时，你需要考虑global_name的内容。事实上，必 须确保无人能修改它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>global_name = <span class="string">'Sir Gumby'</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o.get_name() </span><br><span class="line"><span class="string">'Sir Gumby'</span></span><br></pre></td></tr></table></figure><p>​ 如果尝试创建多个OpenObject对象，将出现问题，因为它们共用同一个变量。 （全局变量/类中的静态变量）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>o1 = OpenObject() </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o2 = OpenObject() </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o1.set_name(<span class="string">'Robin Hood'</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o2.get_name() </span><br><span class="line"><span class="string">'Robin Hood'</span></span><br></pre></td></tr></table></figure><p>​ 如你所见，设置一个对象的名称时，将自动设置另一个对象的名称。这可不是你想要的结果。<br>基本上，你希望对象是抽象的：当调用方法时，无需操心其他的事情，如避免干扰全局变量。 如何将名称“<strong>封装</strong>”在对象中呢？没问题，将其作为一个<strong>属性</strong>即可。</p><ul><li><p>小结：上面提到的是类的静态变量出现的问题，为了避免共用，我们使用<strong>封装</strong>的思想，将其作为对象的属性。</p></li><li><p><strong>封装：将一些东西内容封装到一个地方，你还可以取出来使用</strong>。</p><p>这样的话：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>o1 = ClosedObject() </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o2 = ClosedObject() </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o1.set_name(<span class="string">'小白'</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o2.set_name(<span class="string">'小黑'</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o1.get_name() </span><br><span class="line"><span class="string">'小白'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o2.get_name() </span><br><span class="line"><span class="string">'小黑'</span></span><br></pre></td></tr></table></figure><p>​ ‘小白’这个名称还在！因为对象有了自己的<strong>状态</strong>。对象的的状态由其属性（如名称）描述。对象的方法可能修改这些属性，因此对象将一系列函数（方法）组合起来，并赋予它们访问一些变量（属 性）的权限，而属性可用于在两次函数调用之间存储值。</p></li><li><p>小结：当我们只使用多态而不是用封装，我们会出现问题（全局变量/类的静态变量，共用，一改都改）。封装的思想可以做的真正的隔离，如对象的属性。</p></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承是另一种偷懒的方式（这里是褒义）。程序员总是想避免多次输入同样的代码。可以通过创建函数来达成这个目标，但现在要解决一个更微妙的问题。如果你已经有了一个类，并要创建一个与之很像的类（可能只是新增了几个方法），该如何办呢？创建这个新类时，你不想复制旧类的代码，将其粘贴到新类中。所以我们使用继承。</p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="类到底是什么？"><a href="#类到底是什么？" class="headerlink" title="类到底是什么？"></a>类到底是什么？</h2><ul><li><p>类/类型——一种对象。每个对象都属于特定的类，并被称为该类的<strong>实例</strong>。</p><p>例如，如果你在窗外看到一只鸟，这只鸟就是“鸟类”的一个实例。鸟类是一个非常通用（抽 象）的类，它有多个子类：你看到的那只鸟可能属于子类“云雀”。你可将“鸟类”视为由所有鸟组成的集合，而“云雀”是其一个子集。一个类的对象为另一个类的对象的子集时，前者就是后者的子类。因此“云雀”为“鸟类”的<strong>子类</strong>，而“鸟类”为“云雀”的<strong>超类</strong>。</p></li></ul><blockquote><p>注意 在英语日常交谈中，使用复数来表示类，如birds（鸟类）和larks（云雀）。在Python中， 约定使用单数并将首字母大写，如Bird和Lark。</p></blockquote><blockquote><p>注意 在较旧的Python版本中，类型和类之间泾渭分明：内置对象是基于类型的，而自定义对象是基于类的。因此，你可以创建类，但不能创建类型。在较新的Python 2版本中，这种差别不那么明显。在Python 3中，已不再区分类和类型了。</p></blockquote><h2 id="创建自定义类"><a href="#创建自定义类" class="headerlink" title="创建自定义类"></a>创建自定义类</h2><p>创建自定义类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个类，里面拥有完整的结构：静态变量，动态变量，私有变量，类方法，绑定方法，静态方法，property属性。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age,height,weight)</span>:</span></span><br><span class="line">        self.name = name   <span class="comment"># 属性： 动态变量</span></span><br><span class="line">        self.age = age</span><br><span class="line">        self.height = height</span><br><span class="line">        self.weight = weight</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">f'我叫<span class="subst">&#123;self.name&#125;</span>,今年<span class="subst">&#123;self.age&#125;</span>,身高<span class="subst">&#123;self.height&#125;</span>,体重<span class="subst">&#123;self.weight&#125;</span>'</span>)</span><br><span class="line"><span class="meta">    @property              # property属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bmi</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''bmi指数（体脂） = kg / m ^ 2'''</span></span><br><span class="line">        <span class="keyword">return</span> self.weight / (self.height**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></span><br><span class="line">    daily = <span class="string">'学习'</span>  		   </span><br><span class="line">    __num = <span class="number">0</span>			    <span class="comment"># 属性： 私有变量 </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age,height,weight, grade)</span>:</span></span><br><span class="line">        Person.__init__(self,name,age,height,weight)     <span class="comment"># 在子类的方法中调用父类的方法 :父类名.方法名(self,)</span></span><br><span class="line">        self.grade = grade</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span>          <span class="comment"># 方法:动态方法</span></span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;self.name&#125;</span>今年<span class="subst">&#123;self.age&#125;</span>岁，是<span class="subst">&#123;self.grade&#125;</span>的一名学生'</span>)</span><br><span class="line"><span class="meta">    @classmethod			 # 类方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span><span class="params">(cls)</span>:</span>  		</span><br><span class="line">        cls.__num += <span class="number">1</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNum</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls.__num</span><br><span class="line"><span class="meta">    @staticmethod            # 静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">homework</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'学生得做家庭作业'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1 = Student(<span class="string">'小白'</span>,<span class="number">18</span>,<span class="number">1.8</span>,<span class="number">60</span>,<span class="string">'高三'</span>)   <span class="comment"># 实例/对象</span></span><br><span class="line">print(s1.__dict__)          <span class="comment"># 打印s1对象的所有属性</span></span><br><span class="line">s1.show()                   <span class="comment"># 对象s1调用show方法</span></span><br><span class="line">print(s1.bmi)               <span class="comment"># 使用property装饰器使这个方法变成特殊的属性</span></span><br><span class="line">Student.addNum()            <span class="comment"># 类调用addNum方法。由于类成为调用者会更符合逻辑，使用classmethod装饰器装饰，使之成为类方法。</span></span><br><span class="line">print(Student.getNum())     <span class="comment"># 得到班级人数，因为__num是私有变量，所以需要定义getNum类方法。</span></span><br><span class="line">Student.homework()          <span class="comment"># 使用staticmethod装饰器装饰，使之成为静态方法，静态方法是一个独立的，单纯的函数。</span></span><br></pre></td></tr></table></figure><p>​ 这个例子包含静态变量，动态变量，私有变量，类方法，绑定方法，静态方法，property属性等全部语法。</p><p>​ 不要慌，虽然是这么多，但总体分为两类，一类是属性，一类是方法。接下来就是对属性与方法的详细阐述，但始终是这两大类，只不过角度略有不同。</p><h3 id="从类名的角度使用类"><a href="#从类名的角度使用类" class="headerlink" title="从类名的角度使用类"></a>从类名的角度使用类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age,height,weight)</span>:</span></span><br><span class="line">        self.name = name   <span class="comment"># 属性： 动态变量</span></span><br><span class="line">        self.age = age</span><br><span class="line">        self.height = height</span><br><span class="line">        self.weight = weight</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">f'我叫<span class="subst">&#123;self.name&#125;</span>,今年<span class="subst">&#123;self.age&#125;</span>,身高<span class="subst">&#123;self.height&#125;</span>,体重<span class="subst">&#123;self.weight&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></span><br><span class="line">    daily = <span class="string">'学习'</span></span><br><span class="line">    __num = <span class="number">0</span>			    <span class="comment"># 属性： 私有变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age,height,weight, grade)</span>:</span></span><br><span class="line">        Person.__init__(self,name,age,height,weight)     <span class="comment"># 在子类的方法中调用父类的方法 :父类名.方法名(self,)</span></span><br><span class="line">        self.grade = grade</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span>          <span class="comment"># 方法:动态方法</span></span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;self.name&#125;</span>今年<span class="subst">&#123;self.age&#125;</span>岁，是<span class="subst">&#123;self.grade&#125;</span>的一名学生'</span>)</span><br><span class="line"><span class="meta">    @classmethod			 # 类方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span><span class="params">(cls)</span>:</span></span><br><span class="line">        cls.__num += <span class="number">1</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNum</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls.__num</span><br><span class="line"><span class="meta">    @staticmethod            # 静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">homework</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'学生得做家庭作业'</span>)</span><br><span class="line">s1 = Student(<span class="string">'小白'</span>,<span class="number">18</span>,<span class="number">1.8</span>,<span class="number">60</span>,<span class="string">'高三'</span>)   <span class="comment"># 实例/对象</span></span><br><span class="line">print(s1.__dict__)          <span class="comment"># 打印s1对象的所有属性</span></span><br><span class="line">s1.show()                   <span class="comment"># 对象s1调用show方法</span></span><br><span class="line">Student.addNum()            <span class="comment"># 类调用addNum方法。由于类成为调用者会更符合逻辑，使用classmethod装饰器装饰，使之成为类方法。</span></span><br><span class="line">print(Student.getNum())     <span class="comment"># 得到班级人数，因为__num是私有变量，所以需要定义getNum类方法。</span></span><br><span class="line">Student.homework()          <span class="comment"># 使用staticmethod装饰器装饰，使之成为静态方法，静态方法是一个独立的，单纯的函数。</span></span><br></pre></td></tr></table></figure><h3 id="类名调用类中的属性-类名-属性"><a href="#类名调用类中的属性-类名-属性" class="headerlink" title="类名调用类中的属性(类名.属性)"></a>类名调用类中的属性(类名.属性)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(Student.daily)</span><br><span class="line"><span class="comment"># 学习</span></span><br></pre></td></tr></table></figure><h4 id="特殊的类属性"><a href="#特殊的类属性" class="headerlink" title="特殊的类属性"></a>特殊的类属性</h4><p>对任何类C，下表显示了类C的所有特殊属性：</p><table><thead><tr><th align="center">类属性</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center"><code>C.__name__</code></td><td align="center">类C的名字（字符串）</td></tr><tr><td align="center"><code>C.__doc__</code></td><td align="center">类C的文档字符串</td></tr><tr><td align="center"><code>C.__base__</code></td><td align="center">类C的所有父类构成的元组</td></tr><tr><td align="center"><code>C.__dict__</code></td><td align="center">类C的属性</td></tr><tr><td align="center"><code>C.__module__</code></td><td align="center">类C定义所在的模块</td></tr><tr><td align="center"><code>C.__class__</code></td><td align="center">实例C对应的类（仅新式类中）</td></tr></tbody></table><h3 id="类名调用对象方法"><a href="#类名调用对象方法" class="headerlink" title="类名调用对象方法"></a>类名调用对象方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = Person(<span class="string">'小白'</span>，<span class="number">23</span>，<span class="number">180</span>，<span class="number">65</span>)</span><br><span class="line">Person.show(p)</span><br></pre></td></tr></table></figure><p>它体现了一种<strong>绑定（binding）</strong>的效果，没有实例，方法不能够被调用。</p><p>①方法必须绑定(到一个实例)才能直接被调用（对象.方法）</p><p>②非绑定的方法可能可以被调用，但<strong>实例对象</strong>一定要<strong>明确给出</strong>，才能调用成功。</p><h3 id="类方法（类名-类方法）"><a href="#类方法（类名-类方法）" class="headerlink" title="类方法（类名.类方法）"></a>类方法（类名.类方法）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student.addNum()</span><br><span class="line">print(Student.getNum())</span><br><span class="line"><span class="comment"># 1</span></span><br></pre></td></tr></table></figure><ul><li><code>__num</code>是一个私有变量，只能在类的内部访问，设置它是为了统计班级的人数，所以将其设置为类的一个属性，接着通过类调用<code>addNum</code>方法，实现班级人数加一，然后通过<code>getNum()</code>打印班级人数。</li></ul><h4 id="what"><a href="#what" class="headerlink" title="what"></a>what</h4><ul><li>使用<code>classmethod</code><strong>装饰器</strong>装饰的，第一个参数<code>cls</code>表示<strong>类对象</strong>。</li></ul><h4 id="how"><a href="#how" class="headerlink" title="how"></a>how</h4><ul><li>类方法是通过装饰器<code>classmethod</code>装饰实现的，没有这个装饰器，类是不能调用绑定方法的，只能对象去调用绑定方法。</li></ul><h4 id="where"><a href="#where" class="headerlink" title="where"></a>where</h4><p>①类方法的存在是为了更有逻辑（有时候类名比对象名更适合作为主体，如上面的student的人数，比个体更合适）。</p><p>②不需要实例化，类方法通常用来对类属性的引用或修改。</p><p>③ <code>__new__</code>方法中，第一个参数就是cls</p><p>④ 使用@classmethod多态性构造对象 （effective-python中）</p><p>​ 也就是怎么可以不通过<code>__init__</code>方法来实现类似于重载的构造方法的体现。</p><h3 id="静态方法（类名-静态方法）"><a href="#静态方法（类名-静态方法）" class="headerlink" title="静态方法（类名.静态方法）"></a>静态方法（类名.静态方法）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student.homework() </span><br><span class="line"><span class="comment"># 学生得做家庭作业</span></span><br></pre></td></tr></table></figure><h4 id="what-1"><a href="#what-1" class="headerlink" title="what"></a>what</h4><ul><li>静态方法就是一个<u>普通的函数</u>，只是碰巧在类的定义体中，而不是在模块层定义。</li></ul><h4 id="how："><a href="#how：" class="headerlink" title="how："></a>how：</h4><ul><li>使用<code>staticmethod</code>装饰器进行装饰，且不需要第一位置参数。</li></ul><h4 id="where-1"><a href="#where-1" class="headerlink" title="where"></a>where</h4><p>①不必实例化的时候可以考虑。</p><p>②在没有继承的情况下是可以与<code>classmethod</code>互换使用的，当这个类被继承了成为基类，然后基类因为某些原因被删除了，那么它们就不能互换使用了，而且类方法会比静态方法更合适，静态方法可能报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">p</span>:</span></span><br><span class="line">    name = <span class="string">'小白'</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cl</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(cls.name)</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sta</span><span class="params">()</span>:</span></span><br><span class="line">        print(p.name)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">p1</span><span class="params">(p)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">p1.cl()</span><br><span class="line">p1.sta()</span><br><span class="line"><span class="keyword">del</span> p</span><br><span class="line">p1.cl()     <span class="comment">#  小白</span></span><br><span class="line">p1.sta()    <span class="comment"># 报错     NameError: name 'p' is not defined</span></span><br></pre></td></tr></table></figure><p>注意：静态方法本质上是函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> MethodType</span><br><span class="line">print(isinstance(obj.func1,MethodType))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h3 id="函数与方法的区别"><a href="#函数与方法的区别" class="headerlink" title="函数与方法的区别"></a>函数与方法的区别</h3><p>判断一：</p><ul><li>函数：全都是显性传参</li><li>方法：<strong>隐性传参</strong></li></ul><p>判断二:</p><p>利用types模块类中的FunctionType类和MethodType类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> FunctionType</span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> MethodType</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span><span class="keyword">pass</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类名调用类的静态方法就是一个函数</span></span><br><span class="line">print(isinstance(A.func1,FunctionType))  <span class="comment"># True</span></span><br><span class="line">obj = A()</span><br><span class="line"><span class="comment"># 对象调用静态方法， 实际上成为静态函数</span></span><br><span class="line">print(isinstance(obj.func1,FunctionType))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h1 id="实例化对象"><a href="#实例化对象" class="headerlink" title="实例化对象"></a>实例化对象</h1><h2 id="实例化对象发生了三件事"><a href="#实例化对象发生了三件事" class="headerlink" title="实例化对象发生了三件事"></a>实例化对象发生了三件事</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj = Student() <span class="comment"># 实例化一个对象</span></span><br><span class="line"><span class="comment"># obj称为对象，实例</span></span><br></pre></td></tr></table></figure><ol><li>调用 <code>__new__</code>方法在内存中创建一个对象空间，并返回地址。</li><li>将对象空间传给self参数，自动执行 <code>__init__</code>方法。</li><li>执行 <code>__init__</code>方法时，给对象空间封装其属性。</li></ol><h2 id="对象调用对象的属性（对象-属性）"><a href="#对象调用对象的属性（对象-属性）" class="headerlink" title="对象调用对象的属性（对象.属性）"></a>对象调用对象的属性（对象.属性）</h2><p>增、删、查、改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="string">'''此类是构建学生类'''</span></span><br><span class="line">    daily = <span class="string">'学习'</span>     <span class="comment"># 属性：静态属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,sex)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.sex = sex</span><br><span class="line"></span><br><span class="line">s1 = Student(<span class="string">'小黑'</span>,<span class="string">'未知'</span>)</span><br><span class="line"><span class="comment"># 查询</span></span><br><span class="line">print(s1.name)</span><br><span class="line"><span class="comment"># 删</span></span><br><span class="line"><span class="keyword">del</span> s1.sex</span><br><span class="line">print(s1.__dict__)</span><br><span class="line"><span class="comment"># 增</span></span><br><span class="line">s1.sex = <span class="string">'男'</span></span><br><span class="line"><span class="comment"># 改</span></span><br><span class="line">s1.sex = <span class="string">'女'</span></span><br></pre></td></tr></table></figure><p>注意：如果<u>删的这个属性在对象空间中不存在则会报错</u>，它不会去操作类空间中的属性。</p><h2 id="对象调用类中的属性"><a href="#对象调用类中的属性" class="headerlink" title="对象调用类中的属性"></a>对象调用类中的属性</h2><ol><li><p>一边情况下，对象可以引用类中的属性（类中不存在同名属性），但是不可以修改，因为修改相当于在对象的属性中进行增加。</p></li><li><p>特殊情况：</p><ul><li>当属性变量是可变数据类型，才能在类中间接的改变。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="string">'''此类是构建学生类'''</span></span><br><span class="line">    daily = <span class="string">'学习'</span>     <span class="comment"># 属性：静态属性</span></span><br><span class="line">    examination = <span class="string">'考试'</span></span><br><span class="line">    li = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,sex)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">s1.li.append(<span class="number">2</span>)</span><br><span class="line">print(s1.li)   		<span class="comment"># [2]</span></span><br><span class="line">print(s1.__dict__)	<span class="comment"># &#123;'name': '小黑', 'sex': '女'&#125;</span></span><br><span class="line">print(Student.li)	<span class="comment"># [2]</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="对象调用类中的方法（对象-绑定方法）"><a href="#对象调用类中的方法（对象-绑定方法）" class="headerlink" title="对象调用类中的方法（对象.绑定方法）"></a>对象调用类中的方法（对象.绑定方法）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s1 = Student(<span class="string">'小白'</span>,<span class="number">18</span>,<span class="number">1.8</span>,<span class="number">60</span>,<span class="string">'高三'</span>)   <span class="comment"># 实例/对象</span></span><br><span class="line">print(s1.__dict__)          <span class="comment"># 打印s1对象的所有属性</span></span><br><span class="line">s1.show()                   <span class="comment"># 对象s1调用show方法</span></span><br></pre></td></tr></table></figure><ul><li>对象的方法也称绑定方法或方法。为什么称为绑定？因为在定义中，我们给第一个位置参数传对象的空间地址，这样产生了一种绑定关系，所以称之为绑定方法。self是约定俗成的。它只需要占据第一个位置参数就行。</li><li>使用方法可以访问，操作属性。</li></ul><h2 id="property属性"><a href="#property属性" class="headerlink" title="property属性"></a>property属性</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age,height,weight)</span>:</span></span><br><span class="line">        self.name = name   <span class="comment"># 属性： 动态变量</span></span><br><span class="line">        self.age = age</span><br><span class="line">        self.height = height</span><br><span class="line">        self.weight = weight</span><br><span class="line"><span class="meta">    @property              # property属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bmi</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''bmi指数（体脂） = kg / m ^ 2'''</span></span><br><span class="line">        <span class="keyword">return</span> self.weight / (self.height**<span class="number">2</span>)</span><br><span class="line">p1 = Person(<span class="string">'小白'</span>,<span class="number">23</span>,<span class="number">1.8</span>,<span class="number">65</span>)</span><br><span class="line">print(p1.bmi)</span><br></pre></td></tr></table></figure><h3 id="why"><a href="#why" class="headerlink" title="why"></a>why</h3><ul><li>像体脂这样的<strong>名词</strong>，我们逻辑上更愿意像使用属性的方式去使用它，所以就产生了这种用法。</li></ul><h3 id="how-1"><a href="#how-1" class="headerlink" title="how"></a>how</h3><ul><li><p>加上@property装饰器后，将方法伪装成属性使用，在调用这个方法的时候就可以不用加括号直接得到返回值。</p></li><li><p>设置属性的另一种写法</p><p>property是一个类，通过实例化对象产生属性。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_AAA</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'get的时候运行我啊'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_AAA</span><span class="params">(self,value)</span>:</span></span><br><span class="line">        print(<span class="string">'set的时候运行我啊'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_AAA</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'delete的时候运行我啊'</span>)</span><br><span class="line">    AAA=property(get_AAA,set_AAA,delete_AAA) <span class="comment">#内置property三个参数与get,set,delete一一对应</span></span><br><span class="line"></span><br><span class="line">f1=Foo()</span><br><span class="line">f1.AAA</span><br><span class="line">f1.AAA=<span class="string">'aaa'</span></span><br><span class="line"><span class="keyword">del</span> f1.AAA</span><br></pre></td></tr></table></figure><ul><li>注意：装饰的这个方法，不能有参数。</li></ul><h3 id="where-2"><a href="#where-2" class="headerlink" title="where"></a>where</h3><ul><li>第一个场景：将方法伪装成属性</li><li>第二个场景：和私有属性合作，只能看不能改，用装饰的这种方式，让人只能看不能改。</li><li>第三个场景：能修改，但必须得符合我的逻辑。</li></ul><p>所以property常用来替代私有属性以及访问私有属性的方法。</p><h3 id="方法名-setter"><a href="#方法名-setter" class="headerlink" title="@方法名.setter"></a>@方法名.setter</h3><p>进一步伪装—&gt;可以修改,删除这个属性</p><p>再加一个装饰器 @方法名.setter</p><p>这么做的目的在于，要求符合自己的要求才能改，增加容错能力。</p><p>三部曲：</p><ol><li>必须有这个方法</li><li>@方法名.setter</li><li>再次定义同名方法，它只能接受除self外的一个参数。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">p</span>:</span></span><br><span class="line">    name = <span class="string">'小白'</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cl</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> p.name</span><br><span class="line"><span class="meta">    @cl.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cl</span><span class="params">(self,na)</span>:</span></span><br><span class="line">        p.name = na</span><br><span class="line"><span class="meta">    @cl.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cl</span><span class="params">(self)</span>:</span></span><br><span class="line">    	print(<span class="string">'我执行啦'</span>)</span><br><span class="line">    	<span class="keyword">del</span> p.name</span><br><span class="line"></span><br><span class="line">p1 = p()</span><br><span class="line">print(p1.cl)</span><br><span class="line">p1.cl = <span class="string">'小黑'</span></span><br><span class="line">print(p1.cl)</span><br></pre></td></tr></table></figure><h3 id="方法名-deleter"><a href="#方法名-deleter" class="headerlink" title="@方法名.deleter"></a>@方法名.deleter</h3><p>增加了删除属性的能力：</p><ul><li><p>@方法名.deleter</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> p1.name</span><br><span class="line">并不能真的删除什么，只是调用了对应的被@price.deleter装饰的方法而已。</span><br></pre></td></tr></table></figure></li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol><li>类就像一个模板，它可以实例化多个对象。</li><li>对于方法和属性来说，它有两个角度，一个是类一个是对象，类可以使用静态属性或私有变量，类可以调用类方法和静态方法；对于对象来说，对象可以使用静态属性，动态属性，私有属性等全部属性。对象也可以调用类方法，静态方法，绑定方法等全部。</li></ol><h1 id="类的名称空间"><a href="#类的名称空间" class="headerlink" title="类的名称空间"></a>类的名称空间</h1><p>下面两条语句大致等价：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x)</span>:</span> <span class="keyword">return</span> x * x </span><br><span class="line"></span><br><span class="line">foo = <span class="keyword">lambda</span> x: x * x</span><br></pre></td></tr></table></figure><p>​ 它们都创建一个返回参数平方的函数，并将这个函数关联到变量foo。可以在全局（模块）作用域内定义名称foo，也可以在函数或方法内定义。定义类时情况亦如此：<u>在class语句中定义的代码都是在一个特殊的命名空间（类的命名空间）内执行的，而类的所有成员都可访问这个命名空间。</u>类定义其实就是要执行的代码段。</p><p>类的命名空间：</p><p>​ 第一部分：静态变量</p><p>​ 第二部分：方法、函数</p><p>对象的空间：</p><p>​ 类指针，存储了类所在的内存地址。</p><p>​ 动态属性</p><p>对象和类的关系:<br>单向作用（类指针）：这个单向是从对象到类是一个单项的过程，不能从类引用对象里的属性。</p><p><img src="/learn-python/20190410-python-OOP/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4.png" alt="类与对象的名称空间"></p><p>​ <code>__init__()</code>是在解释器为你创建一个实例后调用的第一个方法。</p><p>​ 调用父类的<code>__new__()</code>来创建对象<code>__new__()</code>必须返回一个合法的实例，这样解释器在调用<code>__init__()</code>时，就可以把这个实例作为self参数传给它。</p><p>​</p><h1 id="类与类之间的关系"><a href="#类与类之间的关系" class="headerlink" title="类与类之间的关系"></a>类与类之间的关系</h1><p>​ 一个类被定义后，目标就是要将它当成一个模块来使用，并且把这些对象嵌入到你的代码中去，同其它数据类型及逻辑执行流混合使用。有两种方法可以在你的代码中利用类。第一种是<strong>组合</strong>（composition）。就是让不同的类混合并加入到其他类中来<u>增加功能和代码重用性</u>。另一种方法是通过<strong>派生</strong>。</p><h2 id="组合（合成）"><a href="#组合（合成）" class="headerlink" title="组合（合成）"></a>组合（合成）</h2><p>一个类的对象是另外一个类对象的属性</p><ul><li>对象变成了另一个对象的一个属性 （这就在一个类和其它组成类之间定义了一种“有一个”（has-a）的关系）</li><li>所有的对象关联这个对象，这样可以方便修改。</li></ul><p>例子：基于圆形类实现一个圆环类,要求接收参数是外圆半径和内圆半径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> pi</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,r)</span>:</span></span><br><span class="line">        self.r = r</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> pi*self.r**<span class="number">2</span>        <span class="comment"># 面积这个因该是源于Circle的， 而圆环只是利用了圆</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perimeter</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*pi*self.r</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circular</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,ci,co)</span>:</span></span><br><span class="line">        ci,co = (co, ci) <span class="keyword">if</span> ci&gt;co <span class="keyword">else</span> (ci ,ci)</span><br><span class="line">        self.c_inner = Circle(ci)</span><br><span class="line">        self.c_outer = Circle(co)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.c_outer.area() - self.c_inner.area()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perimeter</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.c_outer.perimeter() + self.c_inner.perimeter()</span><br></pre></td></tr></table></figure><p>本题考察了含有重叠部分的两个类时，我们该如何设计，以及这样设计的优点。</p><ol><li>实例化要放在init里，</li><li>当我们需要，修改圆的公式时，圆环，圆柱都不需要在修改了，同享这些改变。</li><li>同样的方法不要用两次，而使用组合来减少代码的重复率。</li></ol><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>拿到了对象就像拿到了一切（就像组合中使用的那样）；</p><p>一个类的方法只能由此类的对象去调用；</p><p>一个类的方法的第一个self只接受此类的对象。</p><p>当对象之间有更接近的关系时，派生的概念可能对你的应用程序来说更有意义，特别是当你需要一些相似的对象，但却有少许不同功能的时候。</p><h2 id="再谈继承"><a href="#再谈继承" class="headerlink" title="再谈继承"></a>再谈继承</h2><p>前面提到使用继承是为了解决代码的重复。接下来谈一下继承的语法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>上面代码中：B继承A,A是父类,B是子类；A是<strong>父类/基类/超类</strong>B是<strong>子类/派生类</strong>；子类可以使用父类中的: 方法/静态变量。</p><h3 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>,name)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        print(<span class="string">'%s is eating'</span>%<span class="keyword">self</span>.name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>(<span class="title">Animal</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climb_tree</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        print(<span class="string">'%s is climbing'</span>%<span class="keyword">self</span>.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">小白 = Cat(<span class="string">'小白'</span>)</span><br></pre></td></tr></table></figure><p>​ 上述代码中：先开辟空间,空间里有一个类对象指针指向类Cat。接着调用<code>__init__</code>,对象在自己的空间中找<code>__init__</code>没找到,到Cat类中找<code>__init__</code>也没找到，在找父类Animal中的<code>__init__</code>，完成对对象空间属性的封装。</p><p>​ 当子类和父类的方法重名的时候,我们只使用子类的方法,而不会去调用父类的方法了；<u>当子类想调用父类的同名方法</u>时：</p><ul><li><p>方法一：父类名.方法名(self,)</p></li><li><p>方法二：super(子类名,self).方法名()</p></li><li><p>方法二的简写：super().方法名()</p></li><li><p>注意：方法二是在继承的前提下。</p></li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>,name,food)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.food = food</span><br><span class="line">        <span class="keyword">self</span>.blood = <span class="number">100</span></span><br><span class="line">        <span class="keyword">self</span>.waise = <span class="number">100</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        print(<span class="string">'%s is eating %s'</span><span class="string">%(self.name,self.food)</span>)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>(<span class="title">Animal</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.blood += <span class="number">100</span></span><br><span class="line">        <span class="comment"># 方法一</span></span><br><span class="line">        Animal.eat(<span class="keyword">self</span>)      <span class="comment"># 子类调用父类的同名方法</span></span><br><span class="line">        <span class="comment"># 方法二：</span></span><br><span class="line">        <span class="keyword">super</span>(Cat,<span class="keyword">self</span>).__init_<span class="number">_</span>()</span><br><span class="line">        <span class="comment"># 简写	**推荐				</span></span><br><span class="line">        <span class="keyword">super</span>().__init_<span class="number">_</span>()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climb_tree</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        print(<span class="string">'%s is climbing'</span>%<span class="keyword">self</span>.name)</span><br><span class="line">        <span class="keyword">self</span>.drink()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="title">Animal</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.waise += <span class="number">100</span></span><br><span class="line">        <span class="comment"># 方法一:</span></span><br><span class="line">        Animal.eat(<span class="keyword">self</span>)      <span class="comment"># 子类调用父类的同名方法</span></span><br><span class="line">        <span class="comment"># 方法二：</span></span><br><span class="line">        <span class="keyword">super</span>(Dog,<span class="keyword">self</span>).__init_<span class="number">_</span>()</span><br><span class="line">        <span class="comment"># 简写    **推荐</span></span><br><span class="line">        <span class="keyword">super</span>().__init_<span class="number">_</span>()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">house_keep</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        print(<span class="string">'%s is keeping the house'</span>%<span class="keyword">self</span>.name)</span><br><span class="line">        </span><br><span class="line">小白 = Cat(<span class="string">'小白'</span>,<span class="string">'猫粮'</span>)</span><br><span class="line">小黑 = Dog(<span class="string">'小黑'</span>,<span class="string">'狗粮'</span>)</span><br><span class="line">小白.eat()</span><br><span class="line">小黑.eat()</span><br><span class="line">print(小白.__dict_<span class="number">_</span>)</span><br><span class="line">print(小黑.__dict_<span class="number">_</span>)</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>上面提到了继承的语法规则；以及父类和子类方法的选择：</p><p>①子类的对象,如果去调用方法，永远优先调用自己的；</p><p>②如果自己有就用自己的方法，自己没有就会用父类的；</p><p>③如果自己有还想用父类的 : 直接在子类方法中调父类的方法：父类名.方法名(self)。</p><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>单继承就如前面提到的继承的语法规则。但对于多继承就会存在一个继承顺序。</p><h3 id="知识铺垫："><a href="#知识铺垫：" class="headerlink" title="知识铺垫："></a>知识铺垫：</h3><p>只要继承object类就是新式类；在py3中不存在，在py2中，不主动继承object的类都是经典类。</p><p>在python3 中所有的类都继承object类；python3 中所有的类都是新式类</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>在多继承方面：经典类使用<strong>深度优先</strong>，新式类使用<strong>mro算法</strong>。</p><p>MRO列表</p><ol><li><p>事实上，对于你定义的每一个类，Python 会计算出一个<strong>方法解析顺序（Method Resolution Order, MRO）列表</strong>，<strong>它代表了类继承的顺序</strong>，我们可以通过<code>类名.mro()</code>得到类继承顺序</p></li><li><p>MRO列表是由 <a href="https://www.python.org/download/releases/2.3/mro/" target="_blank" rel="noopener">C3 线性化算法</a>来实现的，一个类的 MRO 列表就是合并所有父类的 MRO 列表.</p></li><li><p>计算公式：</p><p>表头：列表的第一个元素</p><p>表尾：列表中表头以外的元素集合（可以为空）</p><p>表头，表尾</p><p>[A,B,C] : 表头：A 表尾： [B,C]</p><p>[A] : 表头：A 表尾：[]</p><blockquote><p>mro(Child(Base1，Base2)) = [ Child ] + merge( mro(Base1), mro(Base2), [ Base1, Base2] )<br>（其中Child继承自Base1, Base2）</p><p>由公式得到列表，再通过下面的merge合并完成得到结果。</p></blockquote><p>merge合并：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">如计算merge( [<span class="keyword">E</span>,<span class="keyword">O</span>], [<span class="keyword">C</span>,<span class="keyword">E</span>,F,<span class="keyword">O</span>], [<span class="keyword">C</span>] )</span><br><span class="line">有三个列表 ：  ①      ②          ③</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> merge不为空，取出第一个列表列表①的表头<span class="keyword">E</span>，进行判断                              </span><br><span class="line">   各个列表的表尾分别是[<span class="keyword">O</span>], [<span class="keyword">E</span>,F,<span class="keyword">O</span>]，<span class="keyword">E</span>在这些表尾的集合中，因而跳过当前当前列表</span><br><span class="line"><span class="number">2</span> 取出列表②的表头<span class="keyword">C</span>，进行判断</span><br><span class="line">   <span class="keyword">C</span>不在各个列表的集合中，因而将<span class="keyword">C</span>拿出到merge外，并从所有表头删除</span><br><span class="line">   merge( [<span class="keyword">E</span>,<span class="keyword">O</span>], [<span class="keyword">C</span>,<span class="keyword">E</span>,F,<span class="keyword">O</span>], [<span class="keyword">C</span>]) = [<span class="keyword">C</span>] + merge( [<span class="keyword">E</span>,<span class="keyword">O</span>], [<span class="keyword">E</span>,F,<span class="keyword">O</span>] )</span><br><span class="line"><span class="number">3</span> 进行下一次新的merge操作 .....</span><br></pre></td></tr></table></figure><p>补充：也可以在拓扑排序的基础上加上从左到右这个规则进行。</p></li></ol><p>对于新式类继承顺序，使用<code>类名.mro()</code>方法进行查看。</p><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><ul><li><p>super（）严格意义并不是执行父类的方法（单继承是，多继承是有问题的）</p></li><li><p>super是按照self从属类的<strong>mro顺序</strong>，来寻找当前类的下一个类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'in A'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().f1()</span><br><span class="line">        print(<span class="string">'in Foo'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'in Bar'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">info</span><span class="params">(Foo,Bar)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().f1()</span><br><span class="line">        print(<span class="string">'in Info f1'</span>)</span><br><span class="line">a = info()</span><br><span class="line">print(info.__mro__)     <span class="comment"># [info,Foo,Bar,object]</span></span><br><span class="line">a.f1()</span><br><span class="line"><span class="comment">#(&lt;class '__main__.info'&gt;, &lt;class '__main__.Foo'&gt;, &lt;class '__main__.Bar'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)</span></span><br><span class="line"><span class="keyword">in</span> Bar</span><br><span class="line"><span class="keyword">in</span> Foo</span><br><span class="line"><span class="keyword">in</span> Info f1</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>在py3中不需要传参数，自动帮我们寻找当前类的mro顺序的下一个类中的同名方法。</p><ul><li>默认super() , （）里面是(当前类名,self)</li></ul></li><li><p>在py2，新式类中，必须得加参数<code>super(子类的名字，子类的对象).函数名()</code>；而且经典类不支持super（因为它都没有mro）</p></li><li><p>例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在<span class="type">D</span>类中找<span class="keyword">super</span>的<span class="function"><span class="keyword">func</span>，那么可以这样写<span class="title">super</span><span class="params">()</span></span>.<span class="keyword">func</span>()</span><br><span class="line">也可以这样写<span class="keyword">super</span>(<span class="type">D</span>,<span class="keyword">self</span>).<span class="keyword">func</span>()(并且在py2中的新式类中必须这样写)</span><br></pre></td></tr></table></figure></li><li><p>在单继承的程序中，super就是找父类。</p></li><li><p>推荐：是用super来调用父类的方法</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">A</span>(<span class="title">object</span>):</span></span><br><span class="line"><span class="class">    def func(<span class="title">self</span>):</span></span><br><span class="line"><span class="class">        print('<span class="title">in</span> <span class="type">A</span>')</span></span><br><span class="line"><span class="class"># <span class="keyword">class</span> <span class="type">B</span>(<span class="type">A</span>):</span></span><br><span class="line"><span class="class">#     super().func()</span></span><br><span class="line"><span class="class"># b = <span class="type">B</span>()</span></span><br><span class="line"><span class="class"># 上面注释部分会报错    # <span class="type">RuntimeError</span>: super(): no arguments</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">B</span>(<span class="type">A</span>):</span></span><br><span class="line"><span class="class">    def func(<span class="title">self</span>):</span></span><br><span class="line"><span class="class">        # super().func() </span></span><br><span class="line"><span class="class">        super(<span class="type">B</span>,<span class="title">self</span>).func()    # 这两句是等价的</span></span><br><span class="line"><span class="class">b = <span class="type">B</span>()</span></span><br><span class="line"><span class="class">b.func()</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="通过继承实现的类的开发规范"><a href="#通过继承实现的类的开发规范" class="headerlink" title="通过继承实现的类的开发规范"></a>通过继承实现的类的开发规范</h3><p><strong>抽象类</strong>：是一个<strong>开发的规范</strong>，<strong>约束它的所有子类必须实现一些和它同名的方法。</strong>（java中的）</p><p>方法一：（在父类建立约束）对于同名方法的规范，定义一个父类，如果子类没有这个方法，调用父类中的这种方法，就会主动引起一个错误</p><ul><li>优点：不依赖于模块</li><li>推荐的！！！</li><li>缺点：约束力不够强，只有在使用这个方法的时候才会报错。</li></ul><p>例子：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">支付程序</span><br><span class="line">    微信支付 url连接,告诉你参数什么格式</span><br><span class="line">        &#123;<span class="string">'username'</span><span class="symbol">:<span class="string">'用户名'</span></span>,<span class="string">'money'</span><span class="symbol">:</span><span class="number">200</span>&#125;</span><br><span class="line">    支付宝支付 url连接,告诉你参数什么格式</span><br><span class="line">        &#123;<span class="string">'uname'</span><span class="symbol">:<span class="string">'用户名'</span></span>,<span class="string">'price'</span><span class="symbol">:</span><span class="number">200</span>&#125;</span><br><span class="line">    苹果支付</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Payment</span>:     <span class="comment"># 抽象类</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(<span class="keyword">self</span>,money)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">''</span><span class="string">'只要你见到了项目中有这种类,你要知道你的子类中必须实现和pay同名的方法'</span><span class="string">''</span></span><br><span class="line">        raise NotImplementedError(<span class="string">'请在子类中重写同名pay方法'</span>)</span><br><span class="line">        <span class="comment"># raise Exception("随便写一点")   </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Alipay</span>(<span class="title">Payment</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>,name)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(<span class="keyword">self</span>,money)</span></span><span class="symbol">:</span></span><br><span class="line">        dic = &#123;<span class="string">'uname'</span><span class="symbol">:self</span>.name,<span class="string">'price'</span><span class="symbol">:money</span>&#125;</span><br><span class="line">        <span class="comment"># 想办法调用支付宝支付 url连接 把dic传过去</span></span><br><span class="line">        print(<span class="string">'%s通过支付宝支付%s钱成功'</span><span class="string">%(self.name,money)</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeChat</span>(<span class="title">Payment</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>,name)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(<span class="keyword">self</span>,money)</span></span><span class="symbol">:</span></span><br><span class="line">        dic = &#123;<span class="string">'username'</span><span class="symbol">:self</span>.name,<span class="string">'money'</span><span class="symbol">:money</span>&#125;</span><br><span class="line">        <span class="comment"># 想办法调用微信支付 url连接 把dic传过去</span></span><br><span class="line">        print(<span class="string">'%s通过微信支付%s钱成功'</span><span class="string">%(self.name,money)</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span>(<span class="title">Payment</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>,name)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(<span class="keyword">self</span>,money)</span></span><span class="symbol">:</span></span><br><span class="line">        dic = &#123;<span class="string">'name'</span>: <span class="keyword">self</span>.name, <span class="string">'number'</span>: money&#125;</span><br><span class="line">        <span class="comment"># 想办法调用苹果支付 url连接 把dic传过去</span></span><br><span class="line">        print(<span class="string">'%s通过苹果支付%s钱成功'</span> % (<span class="keyword">self</span>.name, money))</span><br><span class="line"></span><br><span class="line"><span class="comment"># aw = WeChat('alex')</span></span><br><span class="line"><span class="comment"># aw.pay(400)</span></span><br><span class="line"><span class="comment"># aa = Alipay('alex')</span></span><br><span class="line"><span class="comment"># aa.pay(400)</span></span><br><span class="line"><span class="comment"># 利用例子类型，实现归一化设计（统一接口）   # 利用反射可以改进</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(name,price,kind)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">if</span> kind == <span class="string">'Wechat'</span><span class="symbol">:</span></span><br><span class="line">        obj = WeChat(name)</span><br><span class="line">    elif kind == <span class="string">'Alipay'</span><span class="symbol">:</span></span><br><span class="line">        obj = Alipay(name)</span><br><span class="line">    elif kind == <span class="string">'Apple'</span><span class="symbol">:</span></span><br><span class="line">        obj = Apple(name)</span><br><span class="line">    obj.pay(price                    </span><br><span class="line"></span><br><span class="line">pay(<span class="string">'alex'</span>,<span class="number">400</span>,<span class="string">'Wechat'</span>)</span><br><span class="line">pay(<span class="string">'alex'</span>,<span class="number">400</span>,<span class="string">'Alipay'</span>)</span><br><span class="line">pay(<span class="string">'alex'</span>,<span class="number">400</span>,<span class="string">'Apple'</span>)</span><br><span class="line"></span><br><span class="line">appa = Apple(<span class="string">'alex'</span>)</span><br><span class="line">appa.fuqian(<span class="number">500</span>)</span><br></pre></td></tr></table></figure><p>补充：在我们查看源码时，很多都写着pass，这是在建议我们继承后要写同名方法。</p><p>方法二：使用<code>abc</code>模块的<code>ABCMeta</code>,<code>abstractmethod</code>来进行<strong>强约束</strong>。</p><ul><li>优点：约束力强，对于没有被<code>@abstractmethod</code>标记的父类方法，如果子类中不存在这个方法就无法创建</li></ul><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">实现抽象类的另一种方式,约束力强,依赖abc模块</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta,abstractmethod</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Payment</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self,money)</span>:</span></span><br><span class="line">        <span class="string">'''只要你见到了项目中有这种类,你要知道你的子类中必须实现和pay同名的方法'''</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">'请在子类中重写同名pay方法'</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Alipay</span><span class="params">(Payment)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self,money)</span>:</span></span><br><span class="line">        dic = &#123;<span class="string">'uname'</span>:self.name,<span class="string">'price'</span>:money&#125;</span><br><span class="line">        <span class="comment"># 想办法调用支付宝支付 url连接 把dic传过去</span></span><br><span class="line">        print(<span class="string">'%s通过支付宝支付%s钱成功'</span>%(self.name,money))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeChat</span><span class="params">(Payment)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self,money)</span>:</span></span><br><span class="line">        dic = &#123;<span class="string">'username'</span>:self.name,<span class="string">'money'</span>:money&#125;</span><br><span class="line">        <span class="comment"># 想办法调用微信支付 url连接 把dic传过去</span></span><br><span class="line">        print(<span class="string">'%s通过微信支付%s钱成功'</span>%(self.name,money))</span><br><span class="line"></span><br><span class="line">WeChat(<span class="string">'alex'</span>) <span class="comment"># 会报错</span></span><br></pre></td></tr></table></figure><h1 id="类中的常用双下划线方法"><a href="#类中的常用双下划线方法" class="headerlink" title="类中的常用双下划线方法"></a>类中的常用双下划线方法</h1><p>双下方法是特殊方法，他是解释器提供的由双下划线加方法名（<code>__方法名__</code>）具有特殊意义的方法,双下方法主要是python源码程序员使用的，我们在开发中尽量不要使用双下方法，但是深入研究双下方法，更有益于我们阅读源码。</p><h2 id="new-构造方法"><a href="#new-构造方法" class="headerlink" title="__new__构造方法"></a><code>__new__</code>构造方法</h2><p>回顾之前实例化的三步走并进行补充：</p><ul><li>先创建一块对象的空间，有一个指针能指向类 ——&gt; 它是由<code>__new__</code>方法完成的。</li><li>在调用init</li></ul><p>该方法需要cls也就是类对象（有了类对象才能开辟对象空间）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创造并返回一个新对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'in __init__'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span>    <span class="comment"># 将类名A给了cls</span></span><br><span class="line">        print(cls)</span><br><span class="line">        print(<span class="string">'in __new__'</span>)</span><br><span class="line">        <span class="comment"># object1 = object.__new__(cls)	  # 两种方法都可以，但一定要显示传cls</span></span><br><span class="line">        object1 = super().__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> object1</span><br><span class="line"></span><br><span class="line">obj = A()</span><br><span class="line"><span class="comment"># 类名（） 先触发__new__并且将类名自动传给cls。</span></span><br><span class="line">print(obj)</span><br></pre></td></tr></table></figure><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>一个类从头到尾只会实例化一次（只创建一次self的空间）。</p><p>这个类的对象不是个性的，主要是实例化对象之后去执行类中的方法。</p><p>节省内存！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baby</span>:</span></span><br><span class="line">    __instance = <span class="literal">None</span>    <span class="comment"># 类似flag  存放的是开的那块空间的地址</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls.__instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls.__instance = super().__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls.__instance</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,cloth,pants)</span>:</span></span><br><span class="line">        self.cloth = cloth</span><br><span class="line">        self.pants = pants</span><br><span class="line">b1 = Baby(<span class="string">'红毛服'</span>,<span class="string">'绿皮裤'</span>)</span><br><span class="line">b2 = Baby(<span class="string">'白衬衫'</span>,<span class="string">'黑豹纹'</span>)</span><br><span class="line">print(b1)</span><br><span class="line">print(b2)</span><br></pre></td></tr></table></figure><p>上述代码是一个单例模式，关键在于只需要调用一次 <code>__new__</code>方法，所以我们借助flag完成单例模式的设计。</p><p>另一种单例（模块导入的方式）：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">单例.py</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baby</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>,cloth,pants)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.cloth = cloth</span><br><span class="line">        <span class="keyword">self</span>.pants = pants</span><br><span class="line">baby = Baby(<span class="string">'红毛服'</span>,<span class="string">'绿皮裤'</span>)</span><br><span class="line"></span><br><span class="line">内容.py</span><br><span class="line">from 单例 import baby</span><br><span class="line">print(baby)   <span class="comment"># 用模块的方式会认为是最简单的。 因为模块的导入是一次性的。</span></span><br></pre></td></tr></table></figure><h2 id="del-析构方法"><a href="#del-析构方法" class="headerlink" title="__del__析构方法"></a><code>__del__</code>析构方法</h2><p>调用del x 不表示调用了 <code>x.__del__()</code>——它只是减少了x的引用计数，当引用计数为0的时候会自动调用 <code>__del__()</code>子类没有就调用父类的。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">A:</span></span><br><span class="line">    <span class="symbol">def</span> <span class="symbol">__del__</span>(<span class="symbol">self</span>):</span><br><span class="line">        <span class="symbol">print</span>('执行<span class="symbol">__del__</span>')</span><br><span class="line"><span class="symbol">a1</span> = <span class="symbol">A</span>()</span><br><span class="line"><span class="symbol">a2</span> = <span class="symbol">a1</span></span><br><span class="line"><span class="symbol">a3</span> = <span class="symbol">a1</span></span><br><span class="line"><span class="symbol">del</span> <span class="symbol">a1</span></span><br><span class="line"><span class="symbol">del</span> <span class="symbol">a2</span></span><br><span class="line"><span class="symbol">del</span> <span class="symbol">a3</span></span><br><span class="line"></span><br><span class="line"># <span class="symbol">print</span>结果 </span><br><span class="line">执行<span class="symbol">__del__</span></span><br></pre></td></tr></table></figure><h2 id="call"><a href="#call" class="headerlink" title="__call__"></a><code>__call__</code></h2><p>callable(对象) 用来判断这个对象能不能运行。</p><p>对象（）调用的是 <code>__call__</code>方法下面的逻辑。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">		print(<span class="string">'-------'</span>)</span><br><span class="line"><span class="comment">#方式一：</span></span><br><span class="line">A()()</span><br><span class="line"><span class="comment">#方式二：</span></span><br><span class="line">a = A()</span><br><span class="line">a()</span><br></pre></td></tr></table></figure><h2 id="len"><a href="#len" class="headerlink" title="__len__"></a><code>__len__</code></h2><p>len(对象) 能不能计算对象的长度，就看对象里有没有定义 <code>__len__</code>方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">len</span><span class="params">(obj)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> obj.__len__</span><br><span class="line">print(lst.__len__)</span><br><span class="line">print(len(obj))</span><br></pre></td></tr></table></figure><p>len(对象) 需要实现这个类中的 <code>__len__</code>方法。</p><h2 id="str"><a href="#str" class="headerlink" title="__str__"></a><code>__str__</code></h2><ol><li>当你想打印对象，%s拼接对象，str（对象）的时候，必须在类内定义一个 <code>__str__</code>方法，才能在打印对象的时候，打印想要的内容，而不是内存地址。</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">print</span>(lst)   		<span class="meta"># 如果没有这个方法，返回的是内存地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>('你好，再见')   <span class="meta"># 如果没有这个方法，返回的是内存地址</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>只能返回 str数据类型。</p></li><li><p>当打印对象，%s拼接对象，str（对象）的时候,我们总是调用这个对象的 <code>__str__</code>方法，如果找不到就调用 <code>__repr__</code>方法。</p></li></ol><h2 id="repr"><a href="#repr" class="headerlink" title="__repr__"></a><code>__repr__</code></h2><ol><li><p><code>__repr__</code>不仅是 <code>__str__</code>的替代品，还有自己的功能</p></li><li><p>用 %r占位或repr(对象)的时候，总是调用<code>__repr__</code>方法。</p></li><li><p>str与repr的关系：</p><ul><li>帮助我们在打印，展示对象的时候更直观的显示对象的内容</li><li>str打印对象，%s拼接对象，str（对象）的时候使用。</li><li>repr是str的备胎，同时还和%r 和repr 有合作关系。</li><li>str范围更大一些，repr更精准，范围更小</li></ul></li></ol><h2 id="item-系列"><a href="#item-系列" class="headerlink" title="__item__ 系列"></a><code>__item__ 系列</code></h2><p>对对象进行类似于字典的操作</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>,name)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(<span class="keyword">self</span>, item)</span></span><span class="symbol">:</span></span><br><span class="line">        print(<span class="string">'get时执行我了'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.name     	<span class="comment"># 设置返回值，才能查的到</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(<span class="keyword">self</span>, key, value)</span></span><span class="symbol">:</span></span><br><span class="line">        print(key,type(key))</span><br><span class="line">        setattr(<span class="keyword">self</span>,key,value)	<span class="comment"># 使用反射修改对象的属性</span></span><br><span class="line">        print(<span class="string">'set时执行我'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span><span class="params">(<span class="keyword">self</span>, key)</span></span><span class="symbol">:</span></span><br><span class="line">        print(<span class="string">'del时执行我'</span>)</span><br><span class="line"></span><br><span class="line">a = Foo(<span class="string">'御姐'</span>)</span><br><span class="line">a[<span class="string">'name'</span>]</span><br><span class="line">a[<span class="string">'name'</span>] = <span class="string">'萝莉'</span></span><br><span class="line">print(a.name)</span><br><span class="line">del a[<span class="string">'name'</span>]</span><br></pre></td></tr></table></figure><h2 id="enter-与-exit"><a href="#enter-与-exit" class="headerlink" title="__enter__与__exit__"></a><code>__enter__与__exit__</code></h2><p>对一个对象类似于进行<strong>with语句上下文管理</strong>的操作，必须在类中定义 <strong>enter</strong> <strong>exit</strong> ， 在<strong>enter</strong>这个方法中必须设置返回值，它将对象返回给obj。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>,name)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        print(<span class="string">'执行__enter__'</span>)</span><br><span class="line">        print(<span class="keyword">self</span>.__dict_<span class="number">_</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>    <span class="comment"># 将对象返回给obj</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(<span class="keyword">self</span>, exc_type, exc_val, exc_tb)</span></span><span class="symbol">:</span></span><br><span class="line">        print(<span class="string">'执行__exit__'</span>)</span><br><span class="line"></span><br><span class="line">with A(<span class="string">'小黑'</span>) as <span class="symbol">obj:</span></span><br><span class="line">    print(obj.name)</span><br><span class="line">    <span class="comment"># print(obj)</span></span><br></pre></td></tr></table></figure><h2 id="iter-可迭代对象"><a href="#iter-可迭代对象" class="headerlink" title="__iter__可迭代对象"></a><code>__iter__</code>可迭代对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="comment"># 将一个对象设置成一个可迭代对象</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">obj = A()</span><br><span class="line"><span class="comment"># 1.for内部将可迭代对象转换成迭代器</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> obj:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.手动将可迭代对象转换成迭代器</span></span><br><span class="line">o = iter(obj)</span><br><span class="line">print(next(o))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.转换成列表</span></span><br><span class="line">print(list(obj))</span><br><span class="line">print(list(obj)[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><h2 id="hash-与-eq"><a href="#hash-与-eq" class="headerlink" title="__hash__与 __eq__"></a><code>__hash__</code>与 <code>__eq__</code></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,count)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.count = count</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;self.name&#125;</span>调用了哈希方法'</span>)</span><br><span class="line">        <span class="comment"># return hash(id(self))</span></span><br><span class="line">        <span class="keyword">return</span> hash(self.count)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;self.name&#125;</span>调用了eq方法'</span>)</span><br><span class="line">        <span class="keyword">if</span> self.__dict__ == other.__dict__:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">a1 = A(<span class="string">'a1'</span>,<span class="number">1</span>)</span><br><span class="line">a2 = A(<span class="string">'a2'</span>,<span class="number">2</span>)</span><br><span class="line">a3 = A(<span class="string">'a2'</span>,<span class="number">2</span>)</span><br><span class="line">a4 = A(<span class="string">'a4'</span>,<span class="number">2</span>)</span><br><span class="line">ls = [a1,a2,a3,a4]</span><br><span class="line">print(set(ls))</span><br></pre></td></tr></table></figure><p>set()函数的实现机制：</p><ul><li>当两个变量的哈希值不相同时，就认为这两个变量是不同的。</li><li>当两个变量哈希值一样时，调用<code>__eq__</code>方法，当返回值为True时认为这两个变量是同一个，应该去除一个。返回FALSE时，不去重。</li></ul><h2 id="使用过的函数"><a href="#使用过的函数" class="headerlink" title="使用过的函数"></a>使用过的函数</h2><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">callable(object)</td><td align="center">判断对象是否是可调用的（如是否是函数或方法）</td></tr><tr><td align="center">getattr(object, name[,default])</td><td align="center">获取属性的值，还可提供默认值</td></tr><tr><td align="center">hasattr(object, name)</td><td align="center">确定对象是否有指定的属性</td></tr><tr><td align="center">isinstance(object, class)</td><td align="center">确定对象是否是指定类的<strong>实例</strong></td></tr><tr><td align="center">issubclass(A, B)</td><td align="center">确定A是否是B的<strong>子类</strong></td></tr><tr><td align="center">setattr(object, name, value)</td><td align="center">将对象的指定属性设置为指定的值</td></tr><tr><td align="center">type(object)</td><td align="center">返回对象的类型</td></tr></tbody></table><h2 id="元类type"><a href="#元类type" class="headerlink" title="元类type"></a>元类type</h2><p>按照Python的一切皆对象理论，类其实也是一个对象，那么类这个对象是从哪里实例化出来的呢？</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="name">type</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br><span class="line">print(<span class="name">type</span>(<span class="name">list</span>))</span><br><span class="line"># &lt;class 'list'&gt;</span><br><span class="line"># &lt;class 'type'&gt;</span><br></pre></td></tr></table></figure><p>type元类是获取该对象从属于的类,而type类比较特殊，Python原则是：一切皆对象，其实类也可以理解为’对象’,而type元类又称作构建类，python中大多数内置的类（包括object）以及自己定义的类，都是由type元类创造的。</p><p>而type类与object类之间的关系比较独特：<strong>object是type类的实例，而type类是object类的子类</strong>，这种关系比较神奇无法使用python的代码表述，因为定义其中一个之前另一个必须存在。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(type(object))  				# &lt;<span class="keyword">class</span> '<span class="symbol">type</span>'&gt;   <span class="symbol">object</span>是<span class="symbol">type</span>的实例化对象</span><br><span class="line"><span class="symbol">print</span>(<span class="symbol">isinstance</span>(<span class="symbol">object,<span class="symbol">type</span></span>))		# <span class="symbol">True</span>   </span><br><span class="line"><span class="symbol">print</span>(<span class="symbol">isinstance</span>(<span class="symbol">type,<span class="symbol">object</span></span>))		# <span class="symbol">True</span></span><br><span class="line"><span class="symbol">print</span>(<span class="symbol">issubclass</span>(<span class="symbol">type,<span class="symbol">object</span></span>))		# <span class="symbol">True</span>   <span class="symbol">type</span>是<span class="symbol">object</span>的子类</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>对象</strong>：对象由属性和方法组成。属性不过是属于对象的变量，而方法是存储在属性中的函数。相比于其他函数，（关联的）方法有一个不同之处，那就是它总是将其所属的对象作为第一个参数，而这个参数通常被命名为self。</p><p><strong>类</strong>：类表示一组（或一类）对象，而每个对象都属于特定的类。类的主要任务是定义其实例将包含的方法。</p><p><strong>多态</strong>：多态指的是能够同样地对待不同类型和类的对象，即无需知道对象属于哪个类就可调用其方法。</p><p>​ 补充：为不同数据类型的实体提供统一的接口（理解：这个人可以接受各种各样的朋友）</p><p><strong>封装</strong>：对象可能隐藏（封装）其内部状态。在有些语言中，这意味着对象的状态（属性） 只能通过其方法来访问。（将一些东西内容封装到一个地方，不受外界干扰，同时你还可以取出来。）</p><p><strong>继承</strong>：一个类可以是一个或多个类的子类，在这种情况下，子类将继承超类的所有方法。 你可指定多个超类，通过这样做可组合正交（独立且不相关）的功能。为此，一种常见的做法是使用一个核心超类以及一个或多个混合超类。</p><p>​ 继承的优点：重载、增强耦合、减少代码重复</p><p>​ 缺点：耦合性增强后、会增加代码难度，牵一发动全身，慎用。</p><p><strong>接口和内省</strong>：一般而言，你无需过于深入地研究对象，而只依赖于多态来调用所需的方 法。然而，如果要确定对象包含哪些方法或属性，有一些函数可供你用来完成这种工作。</p><ul><li>补充：这种手动检查的方法是（hasattr、callable）</li><li>来源：历史上的大部分时间内，Python几乎都只依赖于鸭子类型，即假设所有对象都能完成其工作，同时偶尔使用hasattr来检查所需的方法是否存在。</li></ul><p><strong>抽象基类</strong>：使用模块abc可创建抽象基类。抽象基类用于指定子类必须提供哪些功能，却 不实现这些功能。</p><ul><li>来源：很多其它语言（如Java和Go）都采用引用模块abc提供了官方的解决方案。这个模块为所谓的抽象基类提供了支持。一般而言，抽象类是不能（至少是<strong>不应该</strong>）实例化的类，其职责是定义子类应实现的一组抽象方法。</li></ul><h2 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h2><p>设计<strong>面向对象模型</strong></p><p>​ (1) 将有关问题的描述（程序需要做什么）记录下来，并给所有的名词、动词和形容词加上标记。</p><p>​ (2) 在名词中找出可能的类。</p><p>​ (3) 在动词中找出可能的方法。</p><p>​ (4) 在形容词中找出可能的属性。</p><p>​ (5) 将找出的方法和属性分配给各个类。</p><p>进一步：</p><p>​ (1) 记录（或设想）一系列用例，即使用程序的场景，并尽力确保这些用例涵盖了所有的功能。</p><p>​ (2) 透彻而仔细地考虑每个场景，确保模型包含了所需的一切。如果有遗漏，就加上；如果 有不太对的地方，就修改。不断地重复这个过程，直到对模型满意为止。</p><p>有了你认为行之有效的模型后，就可以着手编写程序了。</p><h2 id="关于面向对象设计的一些思考"><a href="#关于面向对象设计的一些思考" class="headerlink" title="关于面向对象设计的一些思考"></a>关于面向对象设计的一些思考</h2><ol><li><p>将相关的东西放在一起。如果一个函数操作一个全局变量，最好将它们作为一个类的属 性和方法。</p></li><li><p>不要让对象之间过于亲密。方法应只关心其所属实例的属性，对于其他实例的状态，让它们自己去管理就好了。</p></li><li><p>慎用继承，尤其是多重继承。继承有时很有用，但在有些情况下可能带来不必要的复杂性。要正确地使用多重继承很难，要排除其中的bug更难。</p></li><li><p>保持简单。让方法短小紧凑。一般而言，应确保大多数方法都能在30秒内读完并理解。 对于其余的方法，尽可能将其篇幅控制在一页或一屏内。</p></li></ol><hr></div><div><div><div style="text-align:center;color:#555;font-size:14px">-------------The End-------------</div></div></div><div><div class="my_post_copyright"><script src="/js/src/clipboard.min.js"></script><script src="/js/src/jquery2.0/jquery.min.js"></script><script src="/js/src/sweetalert.min.js"></script><p><span>本文标题:</span><a href="/learn-python/20190410-python-OOP.html">Python之面向对象</a></p><p><span>文章作者:</span><a href="/" title="访问 Naqin 的个人博客">Naqin</a></p><p><span>发布时间:</span>2019年04月10日 - 12:04</p><p><span>最后更新:</span>2019年11月05日 - 01:11</p><p><span>原始链接:</span><a href="/learn-python/20190410-python-OOP.html" title="Python之面向对象">https://chennq.top/learn-python/20190410-python-OOP.html</a> <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://chennq.top/learn-python/20190410-python-OOP.html" aria-label="复制成功！"></i></span></p><p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p></div><script>var clipboard=new Clipboard(".fa-clipboard");$(".fa-clipboard").click(function(){clipboard.on("success",function(){swal({title:"",text:"复制成功",icon:"success",showConfirmButton:!0})})})</script></div><div><div id="wechat_subscriber" style="display:block;padding:10px 0;margin:20px auto;width:100%;text-align:center"><img id="wechat_subscriber_qcode" src="/uploads/wechat.jpg" alt="Naqin wechat" style="width:200px;max-width:100%"><div>欢迎看官加我微信！</div></div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>坚持原创技术分享，您的支持将鼓励我继续创作！</div><button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'><span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/uploads/wechatpay.jpg" alt="Naqin 微信支付"><p>微信支付</p></div></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/学习笔记/" rel="tag"><i class="fa fa-tag"></i> 学习笔记</a> <a href="/tags/python/" rel="tag"><i class="fa fa-tag"></i> python</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/learn-python/20190408-python-simulate-database-operation.html" rel="next" title="利用python模拟数据库的增删改查"><i class="fa fa-chevron-left"></i> 利用python模拟数据库的增删改查</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/learn-python/20190411-python-Exception-handling.html" rel="prev" title="Python异常处理">Python异常处理 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div id="gitalk-container"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="https://schema.org/Person"><img class="site-author-image" itemprop="image" src="/uploads/tu6.jpg" alt="Naqin"><p class="site-author-name" itemprop="name">Naqin</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">133</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">30</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">41</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/atlasnq" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:naqin00@hotmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#面向对象"><span class="nav-number">1.</span> <span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对象魔法"><span class="nav-number">1.1.</span> <span class="nav-text">对象魔法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多态"><span class="nav-number">1.2.</span> <span class="nav-text">多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多态和方法"><span class="nav-number">1.3.</span> <span class="nav-text">多态和方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#封装"><span class="nav-number">1.4.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-number">1.5.</span> <span class="nav-text">继承</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类"><span class="nav-number">2.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#类到底是什么？"><span class="nav-number">2.1.</span> <span class="nav-text">类到底是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建自定义类"><span class="nav-number">2.2.</span> <span class="nav-text">创建自定义类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#从类名的角度使用类"><span class="nav-number">2.2.1.</span> <span class="nav-text">从类名的角度使用类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类名调用类中的属性-类名-属性"><span class="nav-number">2.2.2.</span> <span class="nav-text">类名调用类中的属性(类名.属性)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#特殊的类属性"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">特殊的类属性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类名调用对象方法"><span class="nav-number">2.2.3.</span> <span class="nav-text">类名调用对象方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类方法（类名-类方法）"><span class="nav-number">2.2.4.</span> <span class="nav-text">类方法（类名.类方法）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#what"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">what</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#how"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">how</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#where"><span class="nav-number">2.2.4.3.</span> <span class="nav-text">where</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态方法（类名-静态方法）"><span class="nav-number">2.2.5.</span> <span class="nav-text">静态方法（类名.静态方法）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#what-1"><span class="nav-number">2.2.5.1.</span> <span class="nav-text">what</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#how："><span class="nav-number">2.2.5.2.</span> <span class="nav-text">how：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#where-1"><span class="nav-number">2.2.5.3.</span> <span class="nav-text">where</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数与方法的区别"><span class="nav-number">2.2.6.</span> <span class="nav-text">函数与方法的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实例化对象"><span class="nav-number">3.</span> <span class="nav-text">实例化对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#实例化对象发生了三件事"><span class="nav-number">3.1.</span> <span class="nav-text">实例化对象发生了三件事</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象调用对象的属性（对象-属性）"><span class="nav-number">3.2.</span> <span class="nav-text">对象调用对象的属性（对象.属性）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象调用类中的属性"><span class="nav-number">3.3.</span> <span class="nav-text">对象调用类中的属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象调用类中的方法（对象-绑定方法）"><span class="nav-number">3.4.</span> <span class="nav-text">对象调用类中的方法（对象.绑定方法）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#property属性"><span class="nav-number">3.5.</span> <span class="nav-text">property属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#why"><span class="nav-number">3.5.1.</span> <span class="nav-text">why</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#how-1"><span class="nav-number">3.5.2.</span> <span class="nav-text">how</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#where-2"><span class="nav-number">3.5.3.</span> <span class="nav-text">where</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法名-setter"><span class="nav-number">3.5.4.</span> <span class="nav-text">@方法名.setter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法名-deleter"><span class="nav-number">3.5.5.</span> <span class="nav-text">@方法名.deleter</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结论"><span class="nav-number">3.6.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类的名称空间"><span class="nav-number">4.</span> <span class="nav-text">类的名称空间</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类与类之间的关系"><span class="nav-number">5.</span> <span class="nav-text">类与类之间的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#组合（合成）"><span class="nav-number">5.1.</span> <span class="nav-text">组合（合成）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#结论-1"><span class="nav-number">5.1.1.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#再谈继承"><span class="nav-number">5.2.</span> <span class="nav-text">再谈继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#调用过程"><span class="nav-number">5.2.1.</span> <span class="nav-text">调用过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#小结"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多继承"><span class="nav-number">5.3.</span> <span class="nav-text">多继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#知识铺垫："><span class="nav-number">5.3.1.</span> <span class="nav-text">知识铺垫：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#规则"><span class="nav-number">5.3.2.</span> <span class="nav-text">规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#super"><span class="nav-number">5.3.3.</span> <span class="nav-text">super</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过继承实现的类的开发规范"><span class="nav-number">5.3.4.</span> <span class="nav-text">通过继承实现的类的开发规范</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类中的常用双下划线方法"><span class="nav-number">6.</span> <span class="nav-text">类中的常用双下划线方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#new-构造方法"><span class="nav-number">6.1.</span> <span class="nav-text">__new__构造方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单例模式"><span class="nav-number">6.1.1.</span> <span class="nav-text">单例模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#del-析构方法"><span class="nav-number">6.2.</span> <span class="nav-text">__del__析构方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#call"><span class="nav-number">6.3.</span> <span class="nav-text">__call__</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#len"><span class="nav-number">6.4.</span> <span class="nav-text">__len__</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#str"><span class="nav-number">6.5.</span> <span class="nav-text">__str__</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#repr"><span class="nav-number">6.6.</span> <span class="nav-text">__repr__</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#item-系列"><span class="nav-number">6.7.</span> <span class="nav-text">__item__ 系列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#enter-与-exit"><span class="nav-number">6.8.</span> <span class="nav-text">__enter__与__exit__</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iter-可迭代对象"><span class="nav-number">6.9.</span> <span class="nav-text">__iter__可迭代对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hash-与-eq"><span class="nav-number">6.10.</span> <span class="nav-text">__hash__与 __eq__</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用过的函数"><span class="nav-number">6.11.</span> <span class="nav-text">使用过的函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#元类type"><span class="nav-number">6.12.</span> <span class="nav-text">元类type</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">7.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概念"><span class="nav-number">7.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象设计"><span class="nav-number">7.2.</span> <span class="nav-text">面向对象设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于面向对象设计的一些思考"><span class="nav-number">7.3.</span> <span class="nav-text">关于面向对象设计的一些思考</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="fa fa-heartbeat"></i> </span><span class="author" itemprop="copyrightHolder">Naqin</span></div><div class="BbeiAn-info">蒙ICP备 - <a class="beian" target="_blank" href="http://www.miitbeian.gov.cn/" style="color:#f7bb30;text-decoration:none!important;border-bottom:none" rel="nofollow">19005279 </a>| <a class="beian" target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=15012202000146" style="color:#f7bb30;text-decoration:none!important;border-bottom:none;padding-left:30px;background:url(/images/beian.png) no-repeat left center" rel="nofollow">蒙公网安备 15012202000146</a></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><link rel="stylesheet" href="/css/gitalk.css"><script src="/js/src/gitalk.min.js"></script><div id="gitalk-container"></div><script src="/js/src/md5.min.js"></script><script type="text/javascript">var gitalk=new Gitalk({clientID:"377dab7c4f5a8991f28c",clientSecret:"7440711408c01caf520bc000a5a353aef73a142b",repo:"guestbook",owner:"atlasnq",admin:["atlasnq"],id:md5(location.pathname),distractionFreeMode:"true"});gitalk.render("gitalk-container")</script><script type="text/javascript">// Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script></body></html>